---
title: Recycler
description: Affichage de listes
hide_table_of_contents: true
---

# Android : listes avec RecyclerView

TODO:

- produire une recette pour inclure un recyclerview dans une activit√© existante
  - librairies n√©cessaires dans build.gradle
  - Ajout du recycler view dans le layout
  - Adapter de base pour juste mettre le toString de l'objet
  - Raffiner le layout
  - R√©agir dans l'adapter, obtenir un contexte / naviguer
- une video d'explication du "recycler" dans RecyclerView (plus courte)
  - diff√©rence entre create et bind
  - explication avec points d'arret puis ensuite avec trace
- valider la recette en l'appliquant √† un projet existant

<Row>

<Column>

:::danger Avant la s√©ance (2h)

- Vous devez regarder les vid√©os
- Ensuite, commencez les exercices. Arr√™tez-vous quand vous avez compl√©t√© 2 heures.

<Video url="https://youtu.be/nkGseYC3QAw" />

[Code apr√®s video 1](https://github.com/departement-info-cem/3N5-Prog3/tree/main/code/recyclerview)

<Video url="https://youtu.be/gtHix80YUx0" />

[Code apr√®s video 2](https://github.com/departement-info-cem/3N5-Prog3/tree/main/code/RecyclerView-Deboguage)

:::

</Column>

<Column>

:::info √Ä faire pendant la s√©ance

Compl√©ter les exercices de la semaine. Continuer le travail pratique.

:::

</Column>

</Row>

:::tip Recette RecyclerView de String

√âtapes de mise en place d'un `RecyclerView` qui g√®re une liste de `String` sur un projet existant.

Le code de cette recette est disponible [ici](https://github.com/departement-info-cem/3N5-Prog3/tree/a24-kotlin/code/RecetteRecyclerView).

TODO : Mettre √† jour le lien vers le code apr√®s avoir merg√© la branche a24-kotlin

<Tabs queryString="recette-string">
  <TabItem value="build.gradle.kts" label="build.gradle.kts">

    Nous allons utiliser le [ViewBinding](https://developer.android.com/topic/libraries/view-binding#kts) pour la suite des choses. Assurez vous qu'il est activ√© dans votre fichier `build.gradle.kts`.

    ```kotlin
    android {
      ...
      buildFeatures {
        viewBinding = true
      }
    }
    ```

  </TabItem>
  <TabItem value="mon_item.xml" label="mon_item.xml">
    L'interface graphique de chaque item √† afficher dans la liste est d√©finie dans un fichier `xml`, comme c'est le cas pour les fichiers `xml` qui sont utilis√©s pour d√©finir l'interface graphique.

    <Row>

    <Column size="7" >

    Dans l'explorateur de projet, cr√©ez un nouveau fichier `Layout Resource File` dans le dossier `res/layout`.

    ![Create item xml](_14-recycler/create_item_xml.png)

    </Column>

    <Column size="5" >

    Nommez le fichier `mon_item.xml`. Dans `Root element`, choisissez `LinearLayout`.

    ![Create item xml 2](_14-recycler/create_item_xml2.png)
    
    </Column>

    </Row>

    Il faudra personnaliser votre fichier en fonction de ce que vous voulez afficher sur chaque √©l√©ment de liste. 
    
    - Assignez des `id` aux √©l√©ments avec lesquels vous allez interagir.
    - Attention √† la hauteur de chaque √©l√©ment. Ils doivent tous avoir une hauteur fixe ou une hauteur d√©finie en fonction de leur contenu (`wrap_content`).

    Voici un exemple de fichier `mon_item.xml` si on souhaite afficher une `String` dans un `TextView` :

    ```xml
    <?xml version="1.0" encoding="utf-8"?>
    <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
        android:layout_width="match_parent"
        android:layout_height="wrap_content"
        android:orientation="horizontal"
        android:padding="16dp">

        <TextView
            android:id="@+id/tvElement"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_gravity="center"
            android:text="Salut Salut!"
            android:textSize="24sp" />
    </LinearLayout>
    ```
  </TabItem>
  <TabItem value="MonAdapter.kt" label="MonAdapter.kt">

    Vous allez cr√©er une classe qui est responsable de la gestion de **TOUT** les √©l√©ments de la liste et de leur mise √† jour.
    En Android, ce type est classe est appel√©e un **[Adapter](https://developer.android.com/reference/kotlin/android/widget/Adapter)**. 

    Cr√©ez une nouvelle classe `MonAdapter.kt` dans un package `adapters` de votre projet.
    
    ![Recette cr√©er mon adapter](_14-recycler/recette_creer_mon_adapter.png)

    <details>
      <summary>ViewHolder</summary>

      Dans la classe `MonAdapter`, vous devez d√©finir une classe interne, qui sera responsable de g√©rer le contenu affich√© dans **UN SEUL** √©l√©ment de la liste.
      Cette classe est appel√©e un **[ViewHolder](https://developer.android.com/reference/kotlin/androidx/recyclerview/widget/RecyclerView.ViewHolder)**.
      Cette classe ressemble en quelque sorte √† une classe d'**Activit√©**.
      
      ```kotlin
      class MonAdapter {

        // binding nous permet d'acc√©der √† tout le champs de notre layout mon_item.xml
        inner class MonItemViewHolder(private val binding: MonItemBinding) : RecyclerView.ViewHolder(binding.root) {
            fun bind(item: String) {
                binding.tvElement.text = item // On affiche l'√©l√©ment dans le TextView
            }
        }
      }
      ```
    </details>

    <details>
      <summary>DiffCallback</summary>

      Pour que l'`Adapter` sache quels √©l√©ments d'une liste doivent √™tre affich√©s lorsqu'on la modifie, on doit d√©finir un objet qui impl√©mente la classe abstraite **[DiffUtil.ItemCallback](https://developer.android.com/reference/androidx/recyclerview/widget/DiffUtil.ItemCallback)**.

      Nous vous recommandons de d√©finir cet objet dans le m√™me fichier que votre `Adapter`, mais √† l'ext√©rieur de la classe `MonItemAdapter`.

      ```kotlin
      class MonItemAdapter {
          // ...
      }

      object MonItemDiffCallback : DiffUtil.ItemCallback<String>() {
          override fun areItemsTheSame(oldItem: String, newItem: String): Boolean {
              return oldItem == newItem
          }

          override fun areContentsTheSame(oldItem: String, newItem: String): Boolean {
              return oldItem == newItem
          }
      }
      ```
    </details>

    <details>
      <summary>ListAdapter</summary>

      Afin d'acc√©der aux outils de gestion de liste fournis par Android, vous devez √©tendre la classe **[ListAdapter](https://developer.android.com/reference/androidx/recyclerview/widget/ListAdapter)**.

      La classe a besoin du **ViewHolder** et du **DiffCallback** que vous avez d√©fini pr√©c√©demment.

      ```kotlin
      class MonAdapter : ListAdapter<String, MonAdapter.MonItemViewHolder>(MonItemDiffCallback) {
          // ...
      }
      ```

      √Ä ce point ci, votre environnement de d√©veloppement devrait vous indiquer des erreurs. 
      C'est normal, car vous n'avez pas encore impl√©ment√© les m√©thodes requises par la classe ListAdapter.

      Pour corriger cette erreur, vous pouvez placer votre curseur sur l'erreur, et cliquer sur "Implement members", qui va g√©n√©rer les m√©thodes.
      Dans la prochaine √©tape, nous allons remplir ces m√©thodes.

      ![Implementer ListAdapter](_14-recycler/implementer_listadapter.png)
    </details>

    <details>
      <summary>onCreateViewHolder</summary>

      La m√©thode `onCreateViewHolder` est appel√©e lorsqu'un nouvel √©l√©ment de la liste doit √™tre affich√©.

      ```kotlin
      override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MonItemViewHolder {
        val binding: MonItemBinding = MonItemBinding.inflate(LayoutInflater.from(parent.context), parent, false)
        return MonItemViewHolder(binding)
      }
      ```
    </details>

    <details>
      <summary>onBindViewHolder</summary>

      La m√©thode `onBindViewHolder` est appel√©e lorsqu'un √©l√©ment de la liste doit √™tre mis √† jour.

      ```kotlin
      override fun onBindViewHolder(holder: MonItemViewHolder, position: Int) {
        holder.bind(getItem(position))
      }
      ```
    </details>

    <details>
      <summary>R√©sultat</summary>
    
      Votre fichier MonAdapter.kt devrait maintenant ressembler √† ceci :

      ```kotlin
      class MonAdapter : ListAdapter<String, MonAdapter.MonItemViewHolder>(MonItemDiffCallback) {

        // binding nous permet d'acc√©der √† tout le champs de notre layout mon_item.xml
        inner class MonItemViewHolder(private val binding: MonItemBinding) : RecyclerView.ViewHolder(binding.root) {
          fun bind(item: String) {
            binding.tvElement.text = item // On affiche l'√©l√©ment dans le TextView
          }
        }

        override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): MonItemViewHolder {
          val binding: MonItemBinding = MonItemBinding.inflate(LayoutInflater.from(parent.context), parent, false)
          return MonItemViewHolder(binding)
        }

        override fun onBindViewHolder(holder: MonItemViewHolder, position: Int) {
          val item: String = getItem(position)
          holder.bind(item)
        }

      }

      object MonItemDiffCallback : DiffUtil.ItemCallback<String>() {
        override fun areItemsTheSame(oldItem: String, newItem: String): Boolean {
          return oldItem == newItem
        }

        override fun areContentsTheSame(oldItem: String, newItem: String): Boolean {
          return oldItem == newItem
        }
      }
      ```
    </details>

  </TabItem>
  <TabItem value="ActivityMain.xml" label="ActivityMain.xml">

  On ajoute le `RecyclerView` dans le fichier `xml` de l'activit√©.
    
  ```xml
  <?xml version="1.0" encoding="utf-8"?>
  <LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    xmlns:tools="http://schemas.android.com/tools"
    android:id="@+id/main"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    tools:context=".MainActivity">

    <androidx.recyclerview.widget.RecyclerView
      android:id="@+id/rvMonAdapter"
      android:layout_width="match_parent"
      android:layout_height="match_parent"
      app:layoutManager="androidx.recyclerview.widget.LinearLayoutManager"
      app:spanCount="1"
      tools:listitem="@layout/mon_item" />
  </LinearLayout>
  ```

  </TabItem>
  <TabItem value="MainActivity.kt" label="MainActivity.kt">

    <details>
      <summary>ViewBinding</summary>

      Commencez par mettre en place le ViewBinding dans votre activit√©.

      ```kotlin
      class MainActivity : AppCompatActivity() {

        private lateinit var binding: ActivityMainBinding

        override fun onCreate(savedInstanceState: Bundle?) {
          super.onCreate(savedInstanceState)
          binding = ActivityMainBinding.inflate(layoutInflater)
          setContentView(binding.root)
        }
      }
      ```
    </details>

    <details>
      <summary>Configurer le RecyclerView</summary>

      Cr√©ez une m√©thode pour lier l'`Adapteur` que nous venons de cr√©er au `RecyclerView`.

      ```kotlin
      class MainActivity : AppCompatActivity() {

        private lateinit var binding: ActivityMainBinding
        private lateinit var adapter: MonAdapter

        override fun onCreate(savedInstanceState: Bundle?) {
          // ...

          setupRecycler()
        }

        private fun setupRecycler() {
          adapter = MonAdapter() // Cr√©er l'adapteur
          binding.rvMonAdapter.adapter = adapter // Assigner l'adapteur au RecyclerView
          binding.rvMonAdapter.setHasFixedSize(true) // Option pour am√©liorer les performances
          binding.rvMonAdapter.addItemDecoration( // Ajouter un s√©parateur entre chaque √©l√©ment
            DividerItemDecoration(
              binding.rvMonAdapter.context, DividerItemDecoration.VERTICAL
            )
          )
        }
      }
      ```
    </details>

    <details>
      <summary>Remplir le RecyclerView</summary>

      Remplissez le recycler view avec 10 000 √©l√©ments.

      ```kotlin
      class MainActivity : AppCompatActivity() {

        private lateinit var binding: ActivityMainBinding
        private lateinit var adapter: MonAdapter

        override fun onCreate(savedInstanceState: Bundle?) {
          super.onCreate(savedInstanceState)
          binding = ActivityMainBinding.inflate(layoutInflater)
          setContentView(binding.root)

          setupRecycler()
          fillRecycler()
        }

        // ...

        private fun fillRecycler() {
          val items: MutableList<String> = mutableListOf()
          for (i in 1..10000) {
              items.add("Item #$i")
          }
          adapter.submitList(items) // Pour changer le contenu de la liste, utiliser submitList de l'adapteur
        }
      }
      ```

    </details>

  </TabItem>
  <TabItem value="problemes-frequents" label="Probl√®mes fr√©quents">

    <details>
      <summary>Je ne vois qu'un seul √©l√©ment dans ma liste</summary>
    
      <Row>
        <Column size="3" >
          ![Problem item height](_14-recycler/problem_item_height.png)
        </Column>
      </Row>

      <details>
        <summary>Solution</summary>
        <div>
          Si vous ne voyez qu'un seul √©l√©ment dans votre liste, c'est probablement parce que la hauteur de chaque √©l√©ment est d√©finie √† `match_parent`. Cela signifie que chaque √©l√©ment de la liste aura une hauteur √©gale √† la hauteur de son contenu. 
          Assurez-vous que la hauteur de chaque √©l√©ment est d√©finie dans le fichier `xml` de l'√©l√©ment.
        </div>
      </details>
    </details>
  </TabItem>
</Tabs>

:::

:::note Exercices

##### Avant de commencer ü§î

Les exercices Albums Favoris sont it√©ratifs : √† chaque exercices, vous allez commencer √† partir de la fin du pr√©c√©dent. Lorsque vous commencez un exercice, nous vous recommandons d'effectuer une copie du dernier projet pour garder une trace de votre avancement. Cela pourrait vous servir lors des examens ou des travaux pratiques!

### Exercice Albums Favoris : Base

<Row>

<Column size="9" >

Vous devez impl√©menter un RecyclerView simple, o√π chaque entr√©e de la liste est une `String` qui repr√©sente l'un de vos albums favoris. Chaque entr√©e de la liste a une hauteur de 150dp.

</Column>
<Column size="3" >

![Album Favoris : Base](_14-recycler/albums_favoris_base.png)

</Column>

</Row>

### Exercice Albums Favoris : Champs d'une classe

<Row>

<Column size="9" >

Chaque entr√©e de la liste affiche les diff√©rents champs d'une classe `Album`.

Voici la classe `Album` :

```kotlin
data class Album(
    val id: Int,
    val name: String,
    val artistName: String,
)
```

</Column>
<Column size="3" >

![Albums favoris : Classe](_14-recycler/albums_favoris_classe.png)

</Column>

</Row>

### Exercice Albums Favoris : Page de d√©tails

<Row>

<Column size="9" >

Lorsqu'on clique sur un √©l√©ment de la liste, on doit ouvrir une activit√©e de d√©tail li√©e √† l'entr√©e cliqu√©e. La page de d√©tail doit afficher les m√™mes champs qui sont affich√©s dans la liste.

</Column>
<Column size="3" >

![Albums favoris : D√©tails](_14-recycler/albums_favoris_details.png)

</Column>
</Row>

### Exercice Albums Favoris : Supprimer

<Row>

<Column size="9" >

Chaque √©l√©ment de la liste poss√®de un bouton "Supprimer" qui permet de supprimer l'entr√©e de la liste.

</Column>
<Column size="3" >

![Albums favoris : Supprimer](_14-recycler/albums_favoris_supprimer.png)

</Column>
</Row>

### (Optionnel üí™) Exercice Albums Favoris : Finition

<Row>

<Column size="6" >

Pour chaque √©l√©ment de la liste, et dans la page de d√©tails, affichez l'image d'un album √† partir d'une URL. Nous vous recommandons d'utiliser la librairie [Picasso](https://square.github.io/picasso/) pour vous aider.

Voici la classe `Album` mise √† jour :

```kotlin
data class Album(
    val id: Int,
    val name: String,
    val artistName: String,
    val coverUrl: String,
)
```

Ajoutez un s√©parateur entre chaque √©l√©ment de la liste.

</Column>
<Column size="3" >

![Albums favoris : Supprimer](_14-recycler/albums_favoris_finition_item.png)

</Column>
<Column size="3" >

![Albums favoris : Supprimer](_14-recycler/albums_favoris_finition_details.png)

</Column>
</Row>

### (Optionnel Avanc√© üí™) Exercice Albums Favoris : Supprimer en glissant

<Row>

<Column size="6" >

Faites en sorte qu'on soit capable de supprimer un √©l√©ment de la liste en le glissant vers la droite ou vers la gauche.

</Column>
<Column size="3" >

On commence √† glisser de gauche √† droite.

![Albums favoris : Glisser d√©but](_14-recycler/albums_favoris_glisser_debut.png)

</Column>
<Column size="3" >

On a termin√© de glisser, l'item a √©t√© supprim√©.

![Albums favoris : Glisser fin](_14-recycler/albums_favoris_glisser_fin.png)

</Column>
</Row>

### Exercice Bingo

<Row>

<Column size="9">

Vous devez implanter une liste qui sera affich√©e sur les t√©l√©phones des participants d'un jeu de Bingo.

Chaque √©l√©ment de la liste doit avoir :

- Le no de tirage (combien de boules ont √©t√© tir√©es, on commence √† 1)
- Le num√©ro tir√© (al√©atoire entre 1 et 75)
- La lettre du mot BINGO correspondant au chiffre (B : 1 √† 15, I : 16 √† 30, N : 31 √† 45, G : 46 √† 60, O : 61 √† 75)

Pour les pros de l'algorithmie üí™ : faites en sorte que chaque boule n'apparaisse qu'une seule fois dans la liste.

</Column>

<Column size="3" >

![Bingo](_14-recycler/bingo.png)

</Column>

</Row>

### Exercice OrdreAlpha

<Row>

<Column size="6" >

- Vous devez implanter un jeu o√π une liste de pr√©noms est class√©e dans un ordre al√©atoire.
- Chaque √©l√©ment a 2 boutons qui permettent de changer l‚Äôordre dans la liste.
- Le joueur gagne d√®s que la liste est dans l‚Äôordre alphab√©tique. Dans ce cas :
  - On affiche un dialogue de f√©licitations
  - On m√©lange la liste √† nouveau.

</Column>

<Column size="6">

![Alpha](_14-recycler/ordre_alpha.png)

</Column>

</Row>

### Exercice duplicata

<Row>

<Column size="9" >

- Une liste avec les nombres entiers de 1 √† 10
- Chaque fois qu'on appuie sur un item, il se d√©double.

</Column>

<Column size="3">

![Duplicata](_14-recycler/duplicata.png)

</Column>

</Row>

:::
